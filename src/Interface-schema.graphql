# Reactome TypeDefs

# ------------ Interface List
interface Event {
  dbId: ID!
  schemaClass: String
  oldStId: String
  isInDisease: Boolean
  releaseDate: String
  displayName: String
  stId: String
  speciesName: String
  diagramHeight: Int
  hasEHLD: Boolean
  stIdVersion: String
  releaseStatus: String
  name: [String]!
  definition: String
  hasDiagram: Boolean
  isInferred: Boolean
  doi: String
  diagramWidth: Int
  isChimeric: Boolean
  systematicName: String
}

interface PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

interface ReferenceEntity {
  dbId: ID!
  abbreviation: String
  approvalSource: [String]
  approved: Boolean!
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  description: [String]
  displayName: String!
  formula: String
  geneName: [String]
  inn: String
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  trivial: Boolean
  type: String
  url: String!
  variantIdentifier: String!
}

# ----- Types By "Event" Interface -----
# (Type List: Pathway, Reaction)

type Pathway implements Event {
  dbId: ID!
  schemaClass: String
  oldStId: String
  isInDisease: Boolean
  releaseDate: String
  displayName: String
  stId: String
  speciesName: String
  diagramHeight: Int
  hasEHLD: Boolean
  stIdVersion: String
  releaseStatus: String
  name: [String]!
  definition: String
  hasDiagram: Boolean
  isInferred: Boolean
  doi: String
  diagramWidth: Int
  isChimeric: Boolean
  systematicName: String
  hasEvent: [Event] @relation(name: "hasEvent", direction: "OUT")
}

type Reaction implements Event {
  dbId: ID!
  schemaClass: String
  oldStId: String
  isInDisease: Boolean
  releaseDate: String
  displayName: String
  stId: String
  speciesName: String
  diagramHeight: Int
  hasEHLD: Boolean
  stIdVersion: String
  releaseStatus: String
  name: [String]!
  definition: String
  hasDiagram: Boolean
  isInferred: Boolean
  doi: String
  diagramWidth: Int
  isChimeric: Boolean
  systematicName: String
  entityOnOtherCell: [PhysicalEntity]
    @relation(name: "entityOnOtherCell", direction: "OUT")
  input: [PhysicalEntity] @relation(name: "input", direction: "BOTH")
  output: [PhysicalEntity] @relation(name: "output", direction: "Bo")
  requiredInputComponent: [PhysicalEntity]
    @relation(name: "requiredInputComponent", direction: "OUT")
  templateEvent: [Event] @relation(name: "templateEvent", direction: "OUT")
  reverseReaction: [Reaction]
    @relation(name: "reverseReaction", direction: "BOTH")
}

# ----- Types By "PhysicalEntity" Interface -----
# (Type List: Complex, Drug, Set, GenomeEncodedEntity, EntityWithAccessionedSequence, OtherEntity, Polymer, SimpleEntity)
type Complex implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type Drug implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type Set implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
  members: [PhysicalEntity] @relation(name: "hasMember", direction: "OUT")
  candidates: [PhysicalEntity] @relation(name: "hasCandidate", direction: "OUT")
}

type GenomeEncodedEntity implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type EntityWithAccessionedSequence implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type OtherEntity implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type Polymer implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type SimpleEntity implements PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

# ----- Types By "ReferenceEntity" Interface -----
# (Type List: ReferenceGeneProduct, ReferenceMolecule)

type ReferenceGeneProduct implements ReferenceEntity {
  dbId: ID!
  abbreviation: String
  approvalSource: [String]
  approved: Boolean!
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  description: [String]
  displayName: String!
  formula: String
  geneName: [String]
  inn: String
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  trivial: Boolean
  type: String
  url: String!
  variantIdentifier: String!
}

type ReferenceMolecule implements ReferenceEntity {
  dbId: ID!
  abbreviation: String
  approvalSource: [String]
  approved: Boolean!
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  description: [String]
  displayName: String!
  formula: String
  geneName: [String]
  inn: String
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  trivial: Boolean
  type: String
  url: String!
  variantIdentifier: String!
}

# ------ UNDER DEVELOPMENT ------

# # ------ By ReactionLikeEvent Interface
# type BlackBoxEvent implements ReactionLikeEvent {
#   dbId: ID!
#   definition: String
#   displayName: String!
#   isChimeric: Boolean
#   isInDisease: Boolean!
#   isInferred: Boolean!
#   name: [String]!
#   oldStId: String
#   releaseDate: String!
#   releaseStatus: String
#   schemaClass: String!
#   speciesName: String!
#   stId: String!
#   stIdVersion: String!
#   systematicName: String
#   input: [PhysicalEntity] @relation(name: "input", direction: "OUT")
#   output: [PhysicalEntity] @relation(name: "output", direction: "OUT")
#   catalystActivity: [CatalystActivity]
#     @relation(name: "catalystActivity", direction: "OUT")
#   templateEvent: [Event] @relation(name: "templateEvent", direction: "OUT")
# }

# type Depolymerisation implements ReactionLikeEvent {
#   dbId: ID!
#   definition: String
#   displayName: String!
#   isChimeric: Boolean
#   isInDisease: Boolean!
#   isInferred: Boolean!
#   name: [String]!
#   oldStId: String
#   releaseDate: String!
#   releaseStatus: String
#   schemaClass: String!
#   speciesName: String!
#   stId: String!
#   stIdVersion: String!
#   systematicName: String
#   input: [PhysicalEntity] @relation(name: "input", direction: "OUT")
#   output: [PhysicalEntity] @relation(name: "output", direction: "OUT")
#   catalystActivity: [CatalystActivity]
#     @relation(name: "catalystActivity", direction: "OUT")
# }

# type FailedReaction implements ReactionLikeEvent {
#   dbId: ID!
#   definition: String
#   displayName: String!
#   isChimeric: Boolean
#   isInDisease: Boolean!
#   isInferred: Boolean!
#   name: [String]!
#   oldStId: String
#   releaseDate: String!
#   releaseStatus: String
#   schemaClass: String!
#   speciesName: String!
#   stId: String!
#   stIdVersion: String!
#   systematicName: String
#   input: [PhysicalEntity] @relation(name: "input", direction: "OUT")
#   output: [PhysicalEntity] @relation(name: "output", direction: "OUT")
#   catalystActivity: [CatalystActivity]
#     @relation(name: "catalystActivity", direction: "OUT")
# }

# type Polymerisation implements ReactionLikeEvent {
#   dbId: ID!
#   definition: String
#   displayName: String!
#   isChimeric: Boolean
#   isInDisease: Boolean!
#   isInferred: Boolean!
#   name: [String]!
#   oldStId: String
#   releaseDate: String!
#   releaseStatus: String
#   schemaClass: String!
#   speciesName: String!
#   stId: String!
#   stIdVersion: String!
#   systematicName: String
#   input: [PhysicalEntity] @relation(name: "input", direction: "OUT")
#   output: [PhysicalEntity] @relation(name: "output", direction: "OUT")
#   catalystActivity: [CatalystActivity]
#     @relation(name: "catalystActivity", direction: "OUT")
# }

# type Reaction implements ReactionLikeEvent {
#   dbId: ID!
#   definition: String
#   displayName: String!
#   isChimeric: Boolean
#   isInDisease: Boolean!
#   isInferred: Boolean!
#   name: [String]!
#   oldStId: String
#   releaseDate: String!
#   releaseStatus: String
#   schemaClass: String!
#   speciesName: String!
#   stId: String!
#   stIdVersion: String!
#   systematicName: String
#   input: [PhysicalEntity] @relation(name: "input", direction: "OUT")
#   output: [PhysicalEntity] @relation(name: "output", direction: "OUT")
#   catalystActivity: [CatalystActivity]
#     @relation(name: "catalystActivity", direction: "OUT")
#   reverseReaction: [Reaction]
#     @relation(name: "reverseReaction", direction: "BOTH")
# }

# SAMPLE BUSINESS REVIEW SCHEMA

# type User {
#   id: ID!
#   name: String
#   friends: [User] @relation(name: "FRIENDS", direction: "BOTH")
#   reviews: [Review] @relation(name: "WROTE", direction: "OUT")
#   avgStars: Float
#   numReviews: Int
#   recommendations(first: Int = 3): [Business]
# }

# type Business {
#   id: ID!
#   name: String
#   address: String
#   city: String
#   state: String
#   avgStars: Float
#   reviews: [Review] @relation(name: "REVIEWS", direction: "IN")
#   categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
# }

# type Review {
#   id: ID!
#   stars: Int
#   text: String
#   date: Date
#   business: Business @relation(name: "REVIEWS", direction: "OUT")
#   user: User @relation(name: "WROTE", direction: "IN")
# }

# type Category {
#   name: ID!
#   businesses: [Business] @relation(name: "IN_CATEGORY", direction: "IN")
# }

# type Query {
#   usersBySubstring(substring: String): [User]
# }

#--------------------------------------------------------------------------------------------------------------------

# SAMPLE BUSINESS REVIEW SCHEMA

# type User {
#   id: ID!
#   name: String
#   friends: [User] @relation(name: "FRIENDS", direction: "BOTH")
#   reviews: [Review] @relation(name: "WROTE", direction: "OUT")
#   avgStars: Float
#     @cypher(
#       statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN toFloat(avg(r.stars))"
#     )
#   numReviews: Int
#     @cypher(statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN COUNT(r)")
#   recommendations(first: Int = 3): [Business]
#     @cypher(
#       statement: "MATCH (this)-[:WROTE]->(r:Review)-[:REVIEWS]->(:Business)<-[:REVIEWS]-(:Review)<-[:WROTE]-(:User)-[:WROTE]->(:Review)-[:REVIEWS]->(rec:Business) WHERE NOT EXISTS( (this)-[:WROTE]->(:Review)-[:REVIEWS]->(rec) )WITH rec, COUNT(*) AS num ORDER BY num DESC LIMIT $first RETURN rec"
#     )
# }

# type Business {
#   id: ID!
#   name: String
#   address: String
#   city: String
#   state: String
#   avgStars: Float
#     @cypher(
#       statement: "MATCH (this)<-[:REVIEWS]-(r:Review) RETURN coalesce(avg(r.stars),0.0)"
#     )
#   reviews: [Review] @relation(name: "REVIEWS", direction: "IN")
#   categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
# }

# type Review {
#   id: ID!
#   stars: Int
#   text: String
#   date: Date
#   business: Business @relation(name: "REVIEWS", direction: "OUT")
#   user: User @relation(name: "WROTE", direction: "IN")
# }

# type Category {
#   name: ID!
#   businesses: [Business] @relation(name: "IN_CATEGORY", direction: "IN")
# }

# type Query {
#   usersBySubstring(substring: String): [User]
#     @cypher(
#       statement: "MATCH (u:User) WHERE u.name CONTAINS $substring RETURN u"
#     )
# }
